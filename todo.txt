goal: encrypt user data and do not give the business the ability to decrypt it without the user's participation.

Feature set
- login with email address and enter passcode from email --> user is logged in
- data password input UI -- lock and key, etc. to make it clear this is separate from user account
- user encryption key derived from password on client (consistent result!)
- randomly generate salt when password is created, save in user table, and send it to user when they are deriving keys locally
- user encryption key is encrypted via the server, and then stored in local storage
- data encryption key is generated randomly on client
- user encryption key encrypts data encryption key
- encrypted data encryption key is saved in db
- when user logs in on new device, they must supply their password,
	which is used to derive user encryption key, and that key is used to decrypt data encryption key
- unencrypted data encryption key can be used to decrypt / encrypt user data on the client

Notes
- session temporary storage (best available option?) should be used for encrypted local storage of user encryption key
- user encryption key is decrypted via server to local storage
- when user encryption key is decrypted/encrypted via server, there is a check if the device id has been revoked or not
- automatically expire sessions after one month by default -- user adjustable value
- add keep me logged in checkbox
- session encryption key generated by server to encrypt user encryption key locally when session starts
- session encryption key is not stored locally
- when client tries to decrypt locally stored user encryption key, 
	request is sent to server with userID, deviceID, session token, then conditionals are run, 
	and session encryption key is returned or not



Key Management Strategy

	1.	User Authentication:
	•	Each user has a unique account protected by strong authentication mechanisms (e.g., multi-factor authentication).
	•	Upon successful authentication, the user receives a session token to communicate with the server.
	
	2.	User-Side Key Generation:
	•	Each user generates their own encryption key on their device upon first use. This key is never transmitted to or stored on the server.
	•	The user is responsible for securely storing this key. It can be backed up or stored in a secure location accessible only to the user.

	3.	Encryption and Decryption Process:
	•	Initial Setup:
	•	When the user first registers or sets up their account, they generate a strong encryption key locally on their device.
	•	This key is used to encrypt a second key (the data encryption key) which is then used for all data encryption.
	•	The encrypted data encryption key is uploaded to the server, but the user’s encryption key (used for encrypting the data encryption key) is never transmitted.

	4.	Access from Multiple Devices:
	•	When the user logs in from a new device, they authenticate using their credentials and a multi-factor authentication process.
	•	The server provides the encrypted data encryption key to the new device.
	•	The user is prompted to enter their encryption key, which is used to decrypt the data encryption key locally.
	•	The decrypted data encryption key is then used for encrypting/decrypting data on the new device.

	5.	Data Encryption/Decryption:
	•	The client uses the decrypted data encryption key to encrypt/decrypt data locally.
	•	Encrypted data is stored or transmitted as needed, but the data encryption key itself is never stored persistently on the client device after use.

	6.	Backup and Recovery:
	•	Users should be prompted to back up their encryption key securely (e.g., writing it down and storing it in a safe place).
	•	If the user loses their encryption key, they cannot decrypt their data, emphasizing the importance of secure key management by the user.

Workflow for Multiple Devices

	1.	Device Registration:
	•	When a user logs in from a new device, the device is registered and linked to the user’s account.
	•	The server sends the encrypted data encryption key to the device.
	•	The user must enter their encryption key on the new device to decrypt the data encryption key.
	2.	Key Synchronization:
	•	For subsequent logins, the server re-sends the encrypted data encryption key.
	•	The user must enter their encryption key each time to decrypt the data encryption key on each device.
	3.	Key Rotation and Revocation:
	•	Regular key rotation policies ensure that encryption keys are periodically updated by the user.
	•	When a key is rotated, the user re-encrypts the data with the new key and updates the encrypted data encryption key stored on the server.
	•	If a device is compromised, the user can revoke access by rotating their encryption key, making the compromised key invalid.

Security Considerations

	•	Secure Transmission: Ensure all communications between client and server are encrypted using strong TLS protocols.
	•	Authentication: Use robust authentication mechanisms to prevent unauthorized access.
	•	User-Controlled Keys: Ensure that the encryption keys required to decrypt user data are generated and controlled by the user and are never accessible to the server.
	•	Key Storage: Users are responsible for securely storing their encryption keys. This can be done using secure hardware (e.g., hardware security modules, encrypted USB drives) or secure software (e.g., password managers).
	•	Session Management: Implement secure session management to protect session tokens and prevent session hijacking.
	•	Device Trust: Maintain a list of trusted devices for each user, allowing users to review and revoke access as needed.

By ensuring that the encryption keys are user-generated and never transmitted to the server, the business operating the service can never independently decrypt user data without user intervention. This approach puts the control of the encryption keys firmly in the hands of the users, safeguarding their data against unauthorized access by the service provider.