goal: encrypt user data and do not give the business the ability to decrypt it without the user's participation.

Feature set

login with email address and enter passcode from email --> user is logged in

data password input UI -- lock and key, etc. to make it clear this is separate from user account

user inputs a password and PBKDF2 user encryption key derived (with a consistent result!)

randomly generate salt when password is created, save in user table, and send it to user when they are deriving keys locally

user encryption key is encrypted via the server, and then stored in local storage ??

data encryption key is generated randomly on client

user encryption key encrypts data encryption key

encrypted data encryption key is saved in db

when user logs in on new device, they must supply their password,
which is used to derive user encryption key, and that key is used to decrypt data encryption key

unencrypted data encryption key can be used to decrypt / encrypt user data on the client

Notes

session temporary storage (best available option?) should be used for encrypted local storage of user encryption key

user encryption key is decrypted via server to local storage

when user encryption key is decrypted/encrypted via server, there is a check if the device id has been revoked or not

automatically expire sessions after one month by default -- user adjustable value

add keep me logged in checkbox

session encryption key generated by server to encrypt user encryption key locally when session starts

session encryption key is not stored locally

when client tries to decrypt locally stored user encryption key,
request is sent to server with userID, deviceID, session token, then conditionals are run,
and session encryption key is returned or not

End to End Encryption Strategy


1. 
•   Each user has a unique account protected by strong authentication mechanisms (e.g., password and TOTP).
•   Upon successful authentication, the user receives a session token to communicate with the server.

2.  
•   The user enters a password.
•   On their device, the password is used with a random salt to derive a user remote key (URK)
•   The salt is encrypted on the server with a master salt key (loaded from ENV) and the encrypted salt is stored in the DB.
•   A public/ private keypair is generated on the user's device along with a data encryption key (DEK)
•   The URK is used to create an encrypted private key.
•   The URK is stored locally in JWK format, using the IndexedDB API.
•   The DEK is encrypted with the public key.
•   The public key, encrypted private key, and encrypted DEK are stored on the server.
•   The user is responsible for securely storing their data password. It can be backed up or stored in a secure location accessible only to the user.
•   If the user logs out, the URK is deleted from the device.

3. 
•   The URK is used to decrypt the private key and that is used to encrypt / decrypt data locally as needed.


4.  
•   When the user logs in from a new device, they authenticate using their credentials and a multi-factor authentication process.
•   When the user enters their data password on a new device, the salt is decrypted and sent from the server to be used to derive the same user key again and then it is stored locally.
•   A random UUID is generated and stored on the server as a device ID, together with a label for the device, various metadata about the device. The deviceID is also stored locally.
•   The data encryption key can then be decrypted on the new deviice and used for encrypting/decrypting data on the new device.
•   If the user revokes a device, when a PUT or GET request comes from that revoked device, the server returns an error response and invalidates the relevant session token immediately.

Workflow for Multiple Devices

1.  Device Registration:
•   When a user logs in from a new device, the device is registered and linked to the user’s account.
•   The server sends the encrypted data encryption key to the device.
•   The user must enter their encryption key on the new device to decrypt the data encryption key.
2.  Key Synchronization:
•   For subsequent logins, the server re-sends the encrypted data encryption key.
•   The user must enter their encryption key each time to decrypt the data encryption key on each device.
3.  Key Rotation and Revocation:
•   Regular key rotation policies ensure that encryption keys are periodically updated by the user.
•   When a key is rotated, the user re-encrypts the data with the new key and updates the encrypted data encryption key stored on the server.
•   If a device is compromised, the user can revoke access by rotating their encryption key, making the compromised key invalid.

Security Considerations

•   Secure Transmission: Ensure all communications between client and server are encrypted using strong TLS protocols.
•   Authentication: Use robust authentication mechanisms to prevent unauthorized access.
•   User-Controlled Keys: Ensure that the encryption keys required to decrypt user data are generated and controlled by the user and are never accessible to the server.
•   Key Storage: Users are responsible for securely storing their encryption keys. This can be done using secure hardware (e.g., hardware security modules, encrypted USB drives) or secure software (e.g., password managers).
•   Session Management: Implement secure session management to protect session tokens and prevent session hijacking.
•   Device Trust: Maintain a list of trusted devices for each user, allowing users to review and revoke access as needed.

By ensuring that the encryption keys are user-generated and never transmitted to the server, the business operating the service can never independently decrypt user data without user intervention. This approach puts the control of the encryption keys firmly in the hands of the users, safeguarding their data against unauthorized access by the service provider.